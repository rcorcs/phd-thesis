
\section{Identical Code Folding in Linkers}

Google developed an optimisation for the \textit{gold} linker that merges
identical functions on a bit-level~\cite{tallam10,kwan12}.
After placing each function in a separate ELF section, they identify function
sections that have their \textit{text} section bit-identical and also their
relocations point to sections that are identical. A simpler version of this
optimisation was also offered by the MSVC linker~\cite{msvc-icf};

\section{Identical Function Merging}

A similar optimisation for merging identical functions, but instead at the
intermediate representation (IR) level, is also offered by both GCC and
LLVM~\cite{llvm-fm,livska14}.
%The function merging optimisation currently offered by LLVM is only able to
%merge identical functions.
This optimisation is only flexible enough to accommodate simple type mismatches
provided they can be bitcasted in a losslessly way.
%Similarly to the technique proposed by Edler von Koch~et~al.~\cite{edler14},
%LLVM's optimisation also exploits structural similarity among functions.
%However, the current implementation does not allow instructions to differ in
%their opcodes or in the number and type of their input operands.
Although very restrictive, this optimisation guarantees that any pair of
mergeable functions will result in code size reduction with no performance
overhead.
%Its simplicity also benefits compilation time, as the actual merge operation
%is trivial.
Its simplicity also allows for an efficient exploration approach based on computing
a hash of the functions and then using a binary tree to identify equivalent
functions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%We define a congruent group as a set of functions that are candidates for
%function equality.
%To create congruent groups, we build a compound hash value for each previously
%parsed function.
%%%As an optimisation, a hash of the function structure is calculated first, and
%%%two functions are only compared if they have the same hash.

Since hashing is cheap to compute, it allows us to efficiently
%Hashing is used to
group possibly equivalent functions and filter out functions
that are guaranteed to be unique.
%This hash is cheap to compute,
This hash must have the property that if function $F = G$
according to the comparison function, then $hash(F) = hash(G)$.
Therefore, as an optimisation, two functions are only compared if they have the
same hash.
This consistency property is critical to ensuring all possible merging
opportunities are exploited.
Collisions in the hash affect the speed of the pass but not the correctness
or determinism of the resulting transformation.

A function hash is calculated by considering only the number of arguments and
whether a function is varargs, the order of basic blocks (given by the
successors of each basic block in depth first order), and the order of
opcodes of each instruction within each of these basic blocks. This mirrors
the strategy compare() uses to compare functions by walking the BBs in depth
first order and comparing each instruction in sequence. Because this hash
does not look at the operands, it is insensitive to things such as the
target of calls and the constants used in the function, which makes it useful
when possibly merging functions which are the same modulo constants and call
targets.

After that, the pass sorts each function to a congruent class according to
its hash value.
All functions in the module, ordered by hash. Functions with a unique
hash value are easily eliminated.
If the hash value matches the previous value or the next one, we must
consider merging it. Otherwise it is dropped and never considered again.

The functions that remain are inserted into a binary tree, where functions are
the node values themselves.
An order relation is defined over the set of functions.
We need total-ordering, so we need to maintain four properties on the functions set:
\begin{itemize}
\item $a <= a$ (reflexivity);
\item if $a <= b$ and $b <= a$ then $a = b$ (antisymmetry);
\item if $a <= b$ and $b <= c$ then $a <= c$ (transitivity);
\item for all $a$ and $b$, $a <= b$ or $b <= a$ (totality).
\end{itemize}
This total-ordering was made through special function comparison procedure that
returns:
\begin{itemize}
\item 0 when functions are semantically equal,
\item -1 when Left function is less than right function, and
\item 1 for opposite case.
\end{itemize}
This function comparison iterates through each instruction in each basic block.
The FunctionComparator compares two functions to determine whether or not
they will generate machine code with the same behaviour. DataLayout is
used if available. The comparator always fails conservatively (erring on the
side of claiming that two functions are different).


After the previous step is finished, all candidates in a group must be proved to
be really semantically equivalent.

First it Compares the signature and other general attributes of the two functions.
The functions must have identical signature, i.e., the same return type, the same
number of arguments, and the same list of argument types, preserving argument order.
Then they do a CFG-ordered walk since the actual ordering of the blocks in the
linked list is immaterial. This walk starts at the entry block for both
functions, then takes each block from each terminator in order. As an
artifact, this also means that unreachable blocks are ignored.
Finally, two blocks are equivalent if they have equivalent instructions in
exactly the same order.

Functions are kept on binary tree. For each new function F we perform
lookup in binary tree.

%Therefore, by construction, functions are hashed and grouped in O(n log n) time
%complexity.


If we encounter a pair of functions as a candidate for merge, we can create either
an alias or thunk (function wrapper). We prefer to do an alias, which is cheaper
and merging is applied according to following rules:
1. If the address of at least one function is not taken, alias can be used.
2. But if the function is part of COMDAT section that can be replaced, we
must use thunk.
3. If we create a thunk and none of functions is writeable, we can redirect calls
instead.

