
\subsection{Identical Function Merging}

A similar optimisation for merging identical functions, but instead at the
intermediate representation (IR) level, is also offered by both GCC and
LLVM~\cite{llvm-fm,livska14}.
%The function merging optimisation currently offered by LLVM is only able to
%merge identical functions.
This optimisation is only flexible enough to accommodate simple type mismatches
provided they can be bitcast in a lossless way.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A very strict function comparator is used to identify if two functions are 
semantically equivalent.
First it compares the signature and other general attributes of the two functions.
The functions must have identical signature, i.e., the same return type, the same
number of arguments, and exactly the same list of argument types.
Then this function comparator performs a simultaneous walk, in depth
first order, in the functions' control-flow graphs.
This walk starts at the entry block for both functions, then takes each block
from each terminator in order.
As an artifact, this also means that unreachable blocks are ignored.
Finally, it iterates through each instruction in each basic block.
Two blocks are equivalent if they have equivalent instructions in exactly the
same order, without excess.
The comparator always fails conservatively, erring on the side of claiming that
two functions are different.

When a pair of equivalent functions is identified, we can create either
an alias or a \textit{thunk}.
Aliasing entails eliminating one of the functions and replacing all its call-sites
to the other function.
Thunks must be created when neither of the equivalent functions can be eliminated
by aliasing.
In such case, a thunk is created for either one of the functions, replacing its
body by a call to the other function, which allows all call-sites and name
references to both functions to be preserved.
%In such case, the body of one of the functions is replaced by a call to the
%other function, and all call-sites to both functions are preserved.
Aliasing is preferred since it is cheaper and adds no runtime overhead.
The appropriate merging is applied according to following rules:
\begin{itemize}
\item If the address of at least one function is not taken, alias can be used.
\item If the function is part of COMDAT section that can be replaced, we
must use thunk.
\item If we create a thunk and none of functions is writeable, we can redirect calls
instead.
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Similarly to the technique proposed by Edler von Koch~et~al.~\cite{edler14},
%LLVM's optimisation also exploits structural similarity among functions.
%However, the current implementation does not allow instructions to differ in
%their opcodes or in the number and type of their input operands.
Although very restrictive, this optimisation guarantees that any pair of
mergeable functions will result in code size reduction with no performance
overhead.

%Its simplicity also benefits compilation time, as the actual merge operation
%is trivial.
Its simplicity also allows for an efficient exploration approach based on computing
a hash of the functions and then using a binary tree to identify equivalent
functions.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%We define a congruent group as a set of functions that are candidates for
%function equality.
%To create congruent groups, we build a compound hash value for each previously
%parsed function.
%%%As an optimisation, a hash of the function structure is calculated first, and
%%%two functions are only compared if they have the same hash.
Since hashing is cheap to compute, it allows us to efficiently
%Hashing is used to
group possibly equivalent functions and filter out functions
that are obviously unique.
%This hash is cheap to compute,
This hash must have the property that if function $F = G$
according to the comparison function, then $hash(F) = hash(G)$.
Therefore, as an optimisation, two functions are only compared if they have the
same hash.
This consistency property is critical to ensuring all possible merging
opportunities are exploited.
Collisions in the hash affect the speed of the pass but not the correctness
or determinism of the resulting transformation.

A function hash is calculated by considering only the number of arguments and
whether a function contains variadic parameters, the order of basic blocks (given by the
successors of each basic block in depth first order), and the order of
opcodes of each instruction within each of these basic blocks.
This mirrors the strategy of compare() uses to compare functions by walking the BBs in depth
first order and comparing each instruction in sequence. Because this hash
does not look at the operands, it is insensitive to things such as the
target of calls and the constants used in the function, which makes it useful
when possibly merging functions which are the same modulo constants and call
targets.


All functions can be sorted based on their hash value, which ends up grouping
possibly equivalent functions together.
If the hash value of a given function matches any of its adjacent values in
the sorted list, this function must be considered for merging.
%After that, the pass sorts each function to a congruent class according to
%its hash value.
%All functions in the module, ordered by hash.
Functions with a unique hash value can be easily ignored since no other function
will be found equivalent.
%Functions with a unique hash value are also easily eliminated.
%Otherwise it is dropped and never considered again.


The functions that remain are inserted into a binary tree, where functions are
the node values themselves.
An order relation is defined over the set of functions.
We need total-ordering, so we need to maintain four properties on the functions set:
\begin{itemize}
\item $a <= a$ (reflexivity);
\item if $a <= b$ and $b <= a$ then $a = b$ (antisymmetry);
\item if $a <= b$ and $b <= c$ then $a <= c$ (transitivity);
\item for all $a$ and $b$, $a <= b$ or $b <= a$ (totality).
\end{itemize}
This total-ordering was made through special function comparison procedure that
returns:
\begin{itemize}
\item 0 when functions are semantically equal,
\item -1 when the left hand function is less than the right hand function, and
\item 1 for the opposite case.
\end{itemize}

Functions are kept on binary tree. For each new function F we perform
lookup in binary tree.

%After the previous step is finished, all candidates in a group must be proved to
%be really semantically equivalent.

%Therefore, by construction, functions are hashed and grouped in O(n log n) time
%complexity.



